% Remember to use the lgrind style

\Head{}
\File{./java/Dijkstra.java}{2006}{4}{27}{19:09}{9983}
\L{\LB{\C{}/*}}
\L{\LB{_*_Dijkstra.java}}
\L{\LB{_*}}
\L{\LB{_*_//_TODO:_URGENT._The_reset()_method_likely_will_not_reset_ALL_touched_nodes.}}
\L{\LB{_*_//_Should_create_a_new_Set_to_contain_ALL_touched_nodes_throughout_process}}
\L{\LB{_*_//_to_ensure_everything_gets_reset_on_request.}}
\L{\LB{_*}}
\L{\LB{_*_}}
\L{\LB{_*_This_is_where_the_shortest_path_algorithm_goes_to_work.}}
\L{\LB{_*}}
\L{\LB{_*_Created_on_January_28,_2006,_7:14_PM}}
\L{\LB{_*}}
\L{\LB{_*_http://carbon.cudenver.edu/\~{}hgreenbe/sessions/dijkstra/DijkstraApplet.html}}
\L{\LB{_*}\Tab{5}{used_as_influence,_but_no_source_used.}}
\L{\LB{_*}}
\L{\LB{_*_===_Semi-Pseudo_============================}}
\L{\LB{_*_setConnectedDistances(node):}}
\L{\LB{_*}\Tab{6}{For_each_n_connected_to_node,_set_n{'}s_distance_values_and_n{'}s_source_info}}
\L{\LB{_*}\Tab{6}{Return_the_list_of_connected_nodes}}
\L{\LB{_*_closestNodeInT():}}
\L{\LB{_*}\Tab{6}{Return_the_node_in_T_with_the_lowest_distance_value_(that{'}s_not_in_P)}}
\L{\LB{_*}}
\L{\LB{_*_given_start}}
\L{\LB{_*_given_destination}}
\L{\LB{_*_P_=_\{start\}}\Tab{28}{//_permanent_labels}}
\L{\LB{_*_T_=_\{\}}\Tab{28}{//_temporary_labels}}
\L{\LB{_*_next(node)_\{}}
\L{\LB{_*}\Tab{5}{T.addAll(setConnectedDistances(node));}}
\L{\LB{_*}\Tab{5}{n_=_closestNodeInT();}}
\L{\LB{_*}\Tab{5}{T.remove(n);}}
\L{\LB{_*}\Tab{5}{P.add(n);}}
\L{\LB{_*}\Tab{5}{if(!p.contains(destination))}}
\L{\LB{_*}\Tab{7}{next(n);}}
\L{\LB{_*_\}}}
\L{\LB{_*/\CE{}}}
\L{\LB{}}
\L{\LB{}}
\L{\LB{\K{package}_\V{project01};}}
\L{\LB{}}
\L{\LB{\K{import}_\V{java}.\V{util}.*;}}
\L{\LB{\K{import}_\V{java}.\V{util}.\V{concurrent}.\V{CopyOnWriteArraySet};}}
\L{\LB{}}
\L{\LB{}}
\L{\LB{\C{}/**}}
\L{\LB{_*}}
\L{\LB{_*_\CE{}\V{author}_\V{Ian}_\V{Melnick}}}
\L{\LB{\C{}*/\CE{}}}
\L{\LB{\K{public}_\K{class}_\V{Dijkstra}_\{}}
\L{\LB{}\Tab{4}{\K{private}_\K{static}_\K{final}_\K{boolean}_\V{DEBUG}_=_\K{false};}}
\L{\LB{}\Tab{4}{\K{private}_\V{MapComponent}.\V{NodeManager}_\V{nm};}}
\L{\LB{}\Tab{4}{\K{private}_\V{NodeItem}_\V{src},_\V{dest};}}
\L{\LB{}\Tab{4}{\K{private}_\V{LinkedList}\<\V{NodeItem}\>_\V{p};}}
\L{\LB{}\Tab{4}{\K{private}_\V{CopyOnWriteArraySet}\<\V{NodeItem}\>_\V{t};_\C{}//_avoids_duplicates_and_potential_concurrency_problems\CE{}}}
\L{\LB{}\Tab{4}{\K{private}_\V{Dijkstra}_\V{intermediate};}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**_Creates_a_new_instance_of_Dijkstra_*/\CE{}}}
\index{Dijkstra}\Proc{Dijkstra}\L{\LB{}\Tab{4}{\K{public}_\V{Dijkstra}(\V{MapComponent}.\V{NodeManager}_\V{nm},_\V{NodeItem}_\V{src},_\V{NodeItem}_\V{dest})_\{}}
\L{\LB{}\Tab{8}{\K{this}.\V{nm}}\Tab{20}{=_\V{nm};}\Tab{60}{\C{}//_node_manager\CE{}}}
\L{\LB{}\Tab{8}{\K{this}.\V{src}}\Tab{20}{=_\V{src};}\Tab{60}{\C{}//_source_node\CE{}}}
\L{\LB{}\Tab{8}{\K{this}.\V{dest}}\Tab{20}{=_\V{dest};}\Tab{60}{\C{}//_destination_node\CE{}}}
\L{\LB{}\Tab{8}{\K{this}.\V{p}}\Tab{20}{=_\K{new}_\V{LinkedList}\<\V{NodeItem}\>();}\Tab{60}{\C{}//_permanently_labeled_nodes\CE{}}}
\L{\LB{}\Tab{8}{\K{this}.\V{t}}\Tab{20}{=_\K{new}_\V{CopyOnWriteArraySet}\<\V{NodeItem}\>();}\Tab{60}{\C{}//_temporarily_labeled_nodes\CE{}}}
\L{\LB{}\Tab{8}{\K{this}.\V{intermediate}_=_\K{null};}\Tab{60}{\C{}//_use_this_for_multi-floor_searches\CE{}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\K{this}.\V{src}.\V{setDistToMe}(\N{0});}}
\L{\LB{}\Tab{8}{\K{this}.\V{p}.\V{add}(\V{src});}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**_Returns_true_if_source_and_destination_nodes_are_on_different_floors_*/\CE{}}}
\index{multiFloor}\Proc{multiFloor}\L{\LB{}\Tab{4}{\K{private}_\K{boolean}_\V{multiFloor}()_\{}}
\L{\LB{}\Tab{8}{\K{return}_(\V{src}.\V{map}().\V{compareTo}(\V{dest}.\V{map}())!=\N{0});}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**_Returns_the_LinkedList\<NodeItem\>_as_a_string_*/\CE{}}}
\index{listToString}\Proc{listToString}\L{\LB{}\Tab{4}{\K{private}_\V{String}_\V{listToString}(\V{Collection}\<\V{NodeItem}\>_\V{L})_\{}}
\L{\LB{}\Tab{8}{\V{Iterator}\<\V{NodeItem}\>_\V{I}_=_\V{L}.\V{iterator}();}}
\L{\LB{}\Tab{8}{\V{String}_\V{ret}_=_\S{}\3\{\3\SE{};}}
\L{\LB{}\Tab{8}{\K{while}(\V{I}.\V{hasNext}())_\{}}
\L{\LB{}\Tab{12}{\V{ret}_+=_(\V{I}.\V{next}().\V{id}());}}
\L{\LB{}\Tab{12}{\K{if}(\V{I}.\V{hasNext}())}}
\L{\LB{}\Tab{17}{\V{ret}_+=_\S{}\3,\3\SE{};}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{\K{return}_\V{ret}_+=_\S{}\3\}\3\SE{};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**_Return_the_closest_node_in_T_that{'}s_not_in_P_*/\CE{}}}
\index{closestNodeInT}\Proc{closestNodeInT}\L{\LB{}\Tab{4}{\K{private}_\V{NodeItem}_\V{closestNodeInT}()_\{}}
\L{\LB{}\Tab{8}{\V{Iterator}\<\V{NodeItem}\>_\V{i}_=_\V{t}.\V{iterator}();}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{candidate}_=_\K{null};}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{next}_=_\K{null};}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\K{try}_\{}}
\L{\LB{}\Tab{12}{}}
\L{\LB{}\Tab{12}{\C{}//_Set_candidate_to_the_first_node_in_T_not_in_P\CE{}}}
\L{\LB{}\Tab{12}{\K{do}_\{}}
\L{\LB{}\Tab{16}{\V{candidate}_=_\V{i}.\V{next}();}}
\L{\LB{}\Tab{12}{\}_\K{while}_(\V{i}.\V{hasNext}()_\&\&_\V{p}.\V{contains}(\V{candidate}));}}
\L{\LB{}\Tab{12}{}}
\L{\LB{}\Tab{8}{\}_\K{catch}(\V{NoSuchElementException}_\V{err})_\{}}
\L{\LB{}\Tab{12}{\K{if}(\V{nearestFloorLink}(\V{dest}.\V{map}())==\K{null})}}
\L{\LB{}\Tab{16}{\V{Errors}.\V{debug}(\S{}\3No_path_exists_from_\3\SE{}_+_\V{src}_+_\S{}\3_to_\3\SE{}_+_\V{dest});}}
\L{\LB{}\Tab{12}{}}
\L{\LB{}\Tab{12}{\V{p}.\V{add}(\V{dest});}}
\L{\LB{}\Tab{12}{\K{return}_\V{dest};}}
\L{\LB{}\Tab{12}{\C{}//System.exit(1);\CE{}}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//_If_anyone_else_in_T_has_a_shorter_dist,_reset_candidate\CE{}}}
\L{\LB{}\Tab{8}{\K{while}(\V{i}.\V{hasNext}())_\{}}
\L{\LB{}\Tab{12}{\V{next}_=_\V{i}.\V{next}();}}
\L{\LB{}\Tab{12}{\K{if}(\V{next}.\V{getDistToMe}()\<\V{candidate}.\V{getDistToMe}()_\&\&_!\V{p}.\V{contains}(\V{next}))}}
\L{\LB{}\Tab{16}{\V{candidate}_=_\V{next};}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\K{return}_\V{candidate};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**}}
\L{\LB{}\Tab{5}{*_Set_the_Dijkstra-specific_distance_information_on_all_nodes}}
\L{\LB{}\Tab{5}{*_connected_to_n,_and_return_the_list_containing_all_these_connected_nodes.}}
\L{\LB{}\Tab{5}{*/\CE{}}}
\index{setConnectedDistances}\Proc{setConnectedDistances}\L{\LB{}\Tab{4}{\K{private}_\V{LinkedList}\<\V{NodeItem}\>_\V{setConnectedDistances}(\V{NodeItem}_\V{node})_\{}}
\L{\LB{}\Tab{8}{\K{int}_\V{d};}\Tab{40}{\C{}//_store_node_distance_value\CE{}}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{n};}\Tab{40}{\C{}//_temp_node\CE{}}}
\L{\LB{}\Tab{8}{\V{EdgeItem}_\V{e};}\Tab{40}{\C{}//_temp_edge\CE{}}}
\L{\LB{}\Tab{8}{\V{LinkedList}\<\V{NodeItem}\>_\V{c};}\Tab{40}{\C{}//_list_for_nodes_to_set\CE{}}}
\L{\LB{}\Tab{8}{\V{ListIterator}\<\V{NodeItem}\>_\V{i};}\Tab{40}{\C{}//_iterates_over_t\CE{}}}
\L{\LB{}}
\L{\LB{}\Tab{8}{\V{c}_=_\V{nm}.\V{connectedNodes}(\V{node});}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//if(DEBUG)_System.err.println(\3Next_nodes:_\3_+_c);\CE{}}}
\L{\LB{}\Tab{8}{\V{i}_=_\V{c}.\V{listIterator}();}}
\L{\LB{}\Tab{8}{\K{while}(\V{i}.\V{hasNext}())_\{}}
\L{\LB{}\Tab{12}{\V{n}_=_\V{i}.\V{next}();}}
\L{\LB{}\Tab{12}{\V{e}_=_\V{nm}.\V{sharedEdge}(\V{node},\V{n});}}
\L{\LB{}\Tab{12}{}}
\L{\LB{}\Tab{12}{\V{d}_=_\V{node}.\V{getDistToMe}()_+_\V{e}.\V{getDistance}();}}
\L{\LB{}\Tab{12}{}}
\L{\LB{}\Tab{12}{\C{}/*}}
\L{\LB{}\Tab{13}{*_If_node{'}s_distance_hasn{'}t_been_set_yet,_OR_if_the_current_way}}
\L{\LB{}\Tab{13}{*_is_shorter_than_what_it_had_set_before,_then_set_the_Dijkstra}}
\L{\LB{}\Tab{13}{*_info_in_this_node_to_the_current_best_option.}}
\L{\LB{}\Tab{13}{*/\CE{}}}
\L{\LB{}\Tab{12}{\K{if}(\V{n}.\V{getDistToMe}()_\<_\N{0}_\|\,\|_\V{d}_\<_\V{n}.\V{getDistToMe}())_\{}}
\L{\LB{}\Tab{16}{\V{n}.\V{setDistToMe}(\V{d});}}
\L{\LB{}\Tab{16}{\V{n}.\V{setSrcEdge}(\V{e});}}
\L{\LB{}\Tab{16}{\V{n}.\V{setSrcNodeId}(\V{node}.\V{id}());}}
\L{\LB{}\Tab{12}{\}}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\K{return}_\V{c};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**}}
\L{\LB{}\Tab{5}{*_Work_through_nodes_and_set/update_their_labels,}}
\L{\LB{}\Tab{5}{*_adding_to_P_when_we{'}re_sure.}}
\L{\LB{}\Tab{5}{*/\CE{}}}
\index{updateLabels}\Proc{updateLabels}\L{\LB{}\Tab{4}{\K{private}_\K{void}_\V{updateLabels}(\V{NodeItem}_\V{node})_\{}}
\L{\LB{}\Tab{8}{\K{if}(\V{DEBUG})_\V{Errors}.\V{debug}(\S{}\3src:\3\SE{}+\V{src}+\S{}\3,_dest:\3\SE{}+\V{dest});}}
\L{\LB{}\Tab{8}{\K{if}(\V{DEBUG})_\V{Errors}.\V{debug}(\S{}\3P_contains:_\3\SE{}_+_\V{listToString}(\V{p}));}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{n}_=_\K{null};}}
\L{\LB{}\Tab{8}{\V{t}.\V{addAll}(\V{setConnectedDistances}(\V{node}));}}
\L{\LB{}\Tab{8}{\V{t}.\V{removeAll}(\V{p});}\Tab{28}{\C{}//_remove_nodes_already_in_p\CE{}}}
\L{\LB{}\Tab{8}{\K{if}(\V{DEBUG})_\V{Errors}.\V{debug}(\S{}\3T_contains:_\3\SE{}_+_\V{listToString}(\V{t}));}}
\L{\LB{}\Tab{8}{\V{n}_=_\V{closestNodeInT}();}}
\L{\LB{}\Tab{8}{\V{p}.\V{add}(\V{n});}}
\L{\LB{}\Tab{8}{\C{}//while(t.remove(n))_continue;\CE{}}}
\L{\LB{}\Tab{8}{\V{t}.\V{remove}(\V{n});}}
\L{\LB{}\Tab{8}{\K{if}(!\V{p}.\V{contains}(\V{dest}))}}
\L{\LB{}\Tab{12}{\V{updateLabels}(\V{n});}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**}}
\L{\LB{}\Tab{5}{*_Return_route_list,_ordered_from_start_to_destination.}}
\L{\LB{}\Tab{5}{*_Note_that_to_generate_the_list_we_start_from_the_destination_and}}
\L{\LB{}\Tab{5}{*_work_our_way_backwards,_so_if_there{'}s_a_path_inconsistency,_the}}
\L{\LB{}\Tab{5}{*_returned_list_will_indicate_that_the_user_should_start_at_the}}
\L{\LB{}\Tab{5}{*_destination.}}
\L{\LB{}\Tab{5}{*/\CE{}}}
\index{getRoute}\Proc{getRoute}\L{\LB{}\Tab{4}{\K{public}_\V{LinkedList}\<\V{NodeItem}\>_\V{getRoute}()_\{}}
\L{\LB{}\Tab{8}{\C{}/*_Pull_nodes_from_P_starting_from_end,_trace_back_by_edges.}}
\L{\LB{}\Tab{9}{*_Loop:}}
\L{\LB{}\Tab{9}{*}\Tab{13}{while_src_not_in_r,}\Tab{40}{(contains())}}
\L{\LB{}\Tab{9}{*}\Tab{15}{myDistNum_=_lastDistNum_-_lastEdgeLength}}
\L{\LB{}\Tab{9}{*}\Tab{15}{myNode_=_look_for_node_in_P_which_has_myDistNum}}
\L{\LB{}\Tab{9}{*}\Tab{15}{r.addFirst(myNode)}}
\L{\LB{}\Tab{9}{*/\CE{}}}
\L{\LB{}\Tab{8}{\V{LinkedList}\<\V{NodeItem}\>_\V{r}_=_\K{new}_\V{LinkedList}\<\V{NodeItem}\>();}}
\L{\LB{}\Tab{8}{\V{r}.\V{add}(\K{this}.\V{dest});}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\K{int}_\V{distNum};}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{ln},_\V{tn};}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//_Single_floor---normal_op\CE{}}}
\L{\LB{}\Tab{8}{\K{while}(!\V{r}.\V{contains}(\V{src}))_\{}}
\L{\LB{}\Tab{12}{\V{ln}_=_\V{r}.\V{getFirst}();}}
\L{\LB{}\Tab{12}{\C{}//distNum_=_(ln.getDistToMe())_-_(ln.getSrcEdge().getDistance());\CE{}}}
\L{\LB{}\Tab{12}{\V{tn}_=_\V{nm}.\V{getNodeById}(\V{ln}.\V{getSrcNodeId}());}}
\L{\LB{}\Tab{12}{\K{if}(\V{tn}!=\K{null})}}
\L{\LB{}\Tab{16}{\V{r}.\V{addFirst}(\V{tn});}}
\L{\LB{}\Tab{12}{\K{else}_\{}}
\L{\LB{}\Tab{16}{\V{Errors}.\V{debug}(\S{}\3no_source_for_node_\3\SE{}_+_\V{ln});}}
\L{\LB{}\Tab{16}{\K{break};}}
\L{\LB{}\Tab{12}{\}}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//_If_intermediate_exists,_must_add_in_intermediate{'}s_route_first\CE{}}}
\L{\LB{}\Tab{8}{\K{if}(\V{intermediate}!=\K{null})}}
\L{\LB{}\Tab{12}{\V{r}.\V{addAll}(\V{intermediate}.\V{getRoute}());}}
\L{\LB{}\Tab{16}{}}
\L{\LB{}\Tab{8}{\K{return}_\V{r};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\index{getP}\Proc{getP}\L{\LB{}\Tab{4}{\K{public}_\V{LinkedList}\<\V{NodeItem}\>_\V{getP}()_\{_\K{return}_\K{this}.\V{p};_\}}}
\L{\LB{}\Tab{4}{}}
\index{run}\Proc{run}\L{\LB{}\Tab{4}{\K{public}_\K{void}_\V{run}()_\{}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//_First_check_if_source_and_destination_floors_are_different\CE{}}}
\L{\LB{}\Tab{8}{\C{}//_If_they_aren{'}t_the_same,_get_route_details_from_floor_link\CE{}}}
\L{\LB{}\Tab{8}{\C{}//_to_destination,_which_will_be_used_later_when_returning_the\CE{}}}
\L{\LB{}\Tab{8}{\C{}//_correct_route.\CE{}}}
\L{\LB{}\Tab{8}{\K{if}(\V{multiFloor}())_\{}}
\L{\LB{}\Tab{12}{\V{NodeItem}_\V{localLink}_=_\V{nearestFloorLink}(\V{dest}.\V{map}());}}
\L{\LB{}\Tab{12}{\V{NodeItem}_\V{otherLink}_=_\V{localLink}.\V{floorLink}(\V{dest}.\V{map}());}}
\L{\LB{}\Tab{12}{\V{MapComponent}_\V{intmc}_=_\K{new}_\V{MapComponent}(\V{dest}.\V{map}());}}
\L{\LB{}\Tab{12}{\V{intmc}.\V{nm}.\V{loadNodes}();}}
\L{\LB{}\Tab{12}{\V{NodeItem}_\V{otherSrc}}\Tab{31}{=_\V{intmc}.\V{nm}.\V{getNodeById}(\V{otherLink}.\V{id}());}}
\L{\LB{}\Tab{12}{\V{NodeItem}_\V{otherDest}_=_\V{intmc}.\V{nm}.\V{getNodeById}(\V{dest}.\V{id}());}}
\L{\LB{}\Tab{12}{\V{intermediate}_=_\K{new}_\V{Dijkstra}(\V{intmc}.\V{nm},_\V{otherSrc},_\V{otherDest});}}
\L{\LB{}\Tab{12}{\V{intermediate}.\V{run}();}}
\L{\LB{}\Tab{12}{\V{dest}_=_\V{localLink};}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\C{}//_Then_run_normal_algorithm\CE{}}}
\L{\LB{}\Tab{8}{\V{updateLabels}(\V{src});}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{8}{}}
\index{reset}\Proc{reset}\L{\LB{}\Tab{4}{\K{public}_\K{void}_\V{reset}()_\{}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{tn};}}
\L{\LB{}\Tab{8}{\V{ListIterator}\<\V{NodeItem}\>_\V{tI};}}
\L{\LB{}\Tab{8}{\V{tI}_=_\V{p}.\V{listIterator}();}}
\L{\LB{}\Tab{8}{\K{while}(\V{tI}.\V{hasNext}())_\{}}
\L{\LB{}\Tab{12}{(\V{tI}.\V{next}()).\V{resetDijkstraValues}();}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/*_FLOOR_LINK_SEARCHING_*/\CE{}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**}}
\L{\LB{}\Tab{5}{*_Returns_true_if_link_either_directly_links_to_destMap}}
\L{\LB{}\Tab{5}{*_or_links_to_another_floor_which_ultimately_links_to_destMap.}}
\L{\LB{}\Tab{5}{*/\CE{}}}
\index{linksToFloor}\Proc{linksToFloor}\L{\LB{}\Tab{4}{\K{private}_\K{boolean}_\V{linksToFloor}(\V{NodeItem}_\V{link},_\V{String}_\V{destMap})_\{}}
\L{\LB{}\Tab{8}{\K{if}(!\V{link}.\V{isFloorLink}())}}
\L{\LB{}\Tab{12}{\K{return}_\K{false};}}
\L{\LB{}\Tab{8}{\K{if}(\V{link}.\V{hasFloorLink}(\V{destMap}))}}
\L{\LB{}\Tab{12}{\K{return}_\K{true};}}
\L{\LB{}\Tab{8}{\K{else}_\{}}
\L{\LB{}\Tab{12}{\V{Set}\<\V{String}\>_\V{floors}_=_\V{link}.\V{connectedFloors}();}}
\L{\LB{}\Tab{12}{\V{Iterator}\<\V{String}\>_\V{f}_=_\V{floors}.\V{iterator}();}}
\L{\LB{}\Tab{12}{\K{while}(\V{f}.\V{hasNext}())}}
\L{\LB{}\Tab{16}{\K{return}_\V{linksToFloor}(\V{link}.\V{floorLink}(\V{f}.\V{next}()),_\V{destMap});}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{\K{return}_\K{false};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{}\Tab{4}{\C{}/**}}
\L{\LB{}\Tab{5}{*_Returns_the_closest_floor_linking_node}}
\L{\LB{}\Tab{5}{*_from_the_source_node_that_can_provide_a_connection}}
\L{\LB{}\Tab{5}{*_path_to_the_destination{'}s_floor_(i.e.,_through_other}}
\L{\LB{}\Tab{5}{*_floor_links).}}
\L{\LB{}\Tab{5}{*/\CE{}}}
\index{nearestFloorLink}\Proc{nearestFloorLink}\L{\LB{}\Tab{4}{\K{private}_\V{NodeItem}_\V{nearestFloorLink}(\V{String}_\V{destMap})_\{}}
\L{\LB{}\Tab{8}{\V{LinkedList}\<\V{NodeItem}\>_\V{nodesLookedAt}_=_\K{new}_\V{LinkedList}\<\V{NodeItem}\>();}}
\L{\LB{}\Tab{8}{\K{return}_\V{nearestFloorLink}(\V{src},_\V{destMap},_\V{nodesLookedAt});}}
\L{\LB{}\Tab{4}{\}}}
\index{nearestFloorLink}\Proc{nearestFloorLink}\L{\LB{}\Tab{4}{\K{private}_\V{NodeItem}_\V{nearestFloorLink}(\V{NodeItem}_\V{source},_\V{String}_\V{destMap},_\V{LinkedList}\<\V{NodeItem}\>_\V{nodesLookedAt})_\{}}
\L{\LB{}\Tab{8}{\K{if}(\V{linksToFloor}(\V{source},_\V{destMap}))}}
\L{\LB{}\Tab{12}{\K{return}_\V{source};}}
\L{\LB{}\Tab{8}{}}
\L{\LB{}\Tab{8}{\V{nodesLookedAt}.\V{add}(\V{source});}}
\L{\LB{}\Tab{8}{\V{Iterator}\<\V{NodeItem}\>_\V{i}_=_\V{nm}.\V{connectedNodes}(\V{source}).\V{iterator}();}}
\L{\LB{}\Tab{8}{\V{NodeItem}_\V{n};}}
\L{\LB{}\Tab{8}{\K{while}(\V{i}.\V{hasNext}())_\{}}
\L{\LB{}\Tab{12}{\V{n}_=_\V{i}.\V{next}();}}
\L{\LB{}\Tab{12}{\K{if}(!\V{nodesLookedAt}.\V{contains}(\V{n}))_\{}}
\L{\LB{}\Tab{16}{\V{nodesLookedAt}.\V{add}(\V{n});}}
\L{\LB{}\Tab{16}{\K{return}_\V{nearestFloorLink}(\V{n},_\V{destMap},_\V{nodesLookedAt});}}
\L{\LB{}\Tab{12}{\}}}
\L{\LB{}\Tab{8}{\}}}
\L{\LB{}\Tab{8}{\K{return}_\K{null};}}
\L{\LB{}\Tab{4}{\}}}
\L{\LB{}\Tab{4}{}}
\L{\LB{\}}}
